/*--------------------------------*- C++ -*----------------------------------*\
| =========                 |                                                 |
| \\      /  F ield         | OpenFOAM: The Open Source CFD Toolbox           |
|  \\    /   O peration     | Version:  4.0                                   |
|   \\  /    A nd           | Web:      www.OpenFOAM.org                      |
|    \\/     M anipulation  |                                                 |
\*---------------------------------------------------------------------------*/
FoamFile
{
    version     2.0;
    format      ascii;
    class       dictionary;
    location    "constant";
    object      transportProperties;
}
// * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //

phases (water air);

water
{
    transportModel  Newtonian;
    nu              [ 0 2 -1 0 0 0 0 ] 0.0608;
    rho             [ 1 -3 0 0 0 0 0 ] 1000;
}

air
{
    transportModel  Newtonian;
    nu              [ 0 2 -1 0 0 0 0 ] 0.0608;
    rho             [ 1 -3 0 0 0 0 0 ] 1;
}

sigma           	[ 1 0 -2 0 0 0 0 ] 1111;


// B*** kva_interfaceProperties *** //
curvatureModel      vofsmooth; // normal; // If absent default: normal

vofsmoothCoeffs // Requires for curvatureModel "vofsmooth"
{
	
 	// Smooth gradAlpha before calculating nHat?
	/*
	calculateNormal{ // Smooth gradAlpha before calculating nHat?
		smootherKernel-subdict (see below)
	}
	*/
	calculateNormal{
		type 	normalDir;		// See [4], eq. 15
		numIts 	2; 				// Number of Iterations, default = 2
		alpha	alpha.water;	// Name of the alpha (VOF) field, default = "alpha"
	}

	/* // TODO: Implement more generic method:
	calculateNormal{
		type smoothedGradient; // NYI
		smoother{
			smootherKernel-subdict
		}
	}
	*/
	
	// Smoothes the alpha (VOF) field before using it to calculate nHat and the curvature.
	smoothAlpha{
		type 	Csk;	// Take the Csk-weighted average of the smoothed and non-smoothed field.
		Csk 	0.5;	// Weighting coefficient. 0 = no smoothing, 1 = pure smoothing.
		numIts	2;		// Number of Iterations
		smoother{
			type 	interpolate;	// Simple "cell -> face -> cell" interpolation smoother, default = "none"
			numIts 	1;				// Number of Iterations, default = 2
			weightFactor{
				type sqrtAlphaInt;	// Use sqrt(alpha*(1-alpha)) as weighting factor for the smoothing, default = "unweighted"
				alpha alpha.water;	// Name of the alpha (VOF) field, default = "alpha"
			}
		}
	}
	
	// Smooth the curvature directly after it's computed?
	/*
	smoothCurvature{
		smootherKernel-subdict (see below)
	}
	smoothCurvature{
		type 	interpolate;
		numIts 	2;
		weightFactor{
    		weightFactor-subdict (see below)
		}
	}
	*/
	smoothCurvature{ // Smoothes the curvature after it is calculated.
		type 	normalDir;
		numIts 	2;
		alpha	alpha.water;
	}
}

surfaceTensionForceModel{
    densityWeighted         no; // If absent default: no (for my case I found density-weighting to _increase_(!) spurious currents).
    
    // Model to approximate the Dirac delta function in Brackbill's CSF formulation.
    deltaModel{
    	type	snGradPC; // Default: snGrad
    	Cpc		0.5; // original CSF = 0, SSF -> 1 (0.98 was best for sqrtAlphaInt), FSF (sqrtAlphaInt) = 0.5.
    }
    
    // Apply a weighting factor when interpolating the curvature from cell values to face values?
    /*
    interpolateCurvature
    {
    	weightFactor
    	{
    		weightFactor-subdict (see below)
    	}
    }
    */
    interpolateCurvature // c->f
    {
    	weightFactor
    	{
    		type sqrtAlphaInt;
    		alpha alpha.water;
    	}
    }    
}

/* smootherKernel-subdict can be:
  * type none; 									// No smoothing
  * type interpolate (numIts, weightFactor);	// Smooth by interpolating from cell centres to cell faces and back. See [2] for details.
  * type normalDir (numIts, alpha); 			// Smoothes a field in the interface-normal direction. See [4], Eq. 15 for details.
  * type Csk (Csk, numIts, smoother); 			// Take the Csk-weighted average of the smoothed and non-smoothed field. Csk=0: no smoothing. Csk=1: pure smoothing. See [4], Eq. 12 for details.
  * NYI: type CELESTE ...; // specialised kernel based on interpolate for the curvature
  * NYI: type convolve cosine 0.75;
*/
/* weightFactor-subdict can be:
  * type unweighted;			// Does not apply any weighting
  * type sqrtAlphaInt (alpha);	// sqrt( alpha * (1-alpha) )
  * NYI: type CELESTE (power);	// ( alpha * (1-alpha) )^power
*/

// E*** kva_interfaceProperties *** //



// ************************************************************************* //
